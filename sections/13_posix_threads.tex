\section{POSIX Threads Programming}

Für UNIX Systeme steht ein stardardisiertes threads programming interface in C zur Verfügung (POSIX threads / pthreads).


\subsection{UNIX Process vs. UNIX Thread}

\begin{center}
    \includegraphics[width=0.75\columnwidth]{images/posix_process_threads.png}
\end{center}


\subsubsection{UNIX Process}

\begin{outline}
    \1 \textbf{heavyweight process} (generiert von Betriebssystem)
    \1 Prozess erfordert \textbf{erheblichen overhead}, da Informationen über Programmressourcen und 
        den Ausführungsstatus des Programms, beispielsweise:
        \2 Prozess-ID, Prozessgruppen-ID, Benutzer-ID und Gruppen-ID
        \2 Environment, Programmanweisungen
        \2 Register, Stack, Heap
        \2 Datei-Deskriptoren, Signal-Aktionen
        \2 Gemeinsame Bibliotheken
        \2 Werkzeuge für die prozessübergreifende Kommunikation
\end{outline}


\subsubsection{UNIX Thread}

\begin{outline}
    \1 lightweight 'process' (weniger overhead)
    \1 Unabhängiger 'stream of instructions', welcher simultan mit anderen 'streams of instructions' ablaufen kann %CHECK: german names...
    \1 Prozedur, welche unabhängig von ihrem (aufrufenden) main-Programm abläuft
    \1 \textbf{Threadsexistieren in einem Prozess und nutzen dessen Ressourcen}
        \2 Sobald ein Prozess ended, enden auch die darin existierenden Threads!
    \1 \textbf{Ein Thread benutzt den gleichen Adressraum wie andere Threads im gleichen Prozess}
        \2 Daten können einfach mit anderen Threads im gleichen Prozess geteilt werden
    \1 Threads werden vom Betriebssystem 'gescheduled'
    \1 Ein Thread dupliziert nur die essenziellen Ressourcen die er braucht, um unabhängig 'schedulable' zu sein:
        \2 Stack pointer, Register
        \2 Scheduling properties (policy / priority)
        \2 Set of pendding and blocked signals  % CHECK: in german...
        \2 Thread-spezifische Daten
\end{outline}

\vspace{0.1cm}

\textbf{ \textrightarrow\ Gleichzeitigkeit wird in der Programmierung mit Threads umgesetzt!}


\subsection{pthreads API}

\subsubsection{Includes / Compile \& Link}

\begin{outline}
    \1 \mylstbox{#include <pthread.h>} wird benötigt
    \1 Methoden der pthreads API starten mit \mylstbox{pthread_}
    \1 Source files, welche pthreads verwenden, sollen mit \mylstbox{-pthread} kompiliert werden
    \1 Für das file-linking muss der command \mylstbox{-lpthread} verwenet werden
\end{outline}


\example{Compiling / Linking file printer.c}


%TODO: formatting broken?!
\begin{description}
    \item[Compiling:] \lstinline|clang -c -Wall -pthread printer.c|
    \item[Linking:]   \lstinline|clang -o printer printer.o -Wall -lpthread|
\end{description}


\subsubsection{Thread starten / beenden}

\begin{outline}
    \1 Jede Funktion mit der folgenden interface kann eine Thread-Methode werden
        \2 Als Parameter / Return-Wert sind alle Pointer-Datentypen möglich \\ %CHECK if this is correct...
        \mylstbox[aboveskip=1mm, linewidth=\linewidth, morekeywords={[3], arg}]{void* threadRoutine(void* arg);}
    \1 Ein Thread wird mit der folgenden Funktion gestartet:
        \lstinputlisting[aboveskip=1mm, linewidth=\linewidth, morekeywords={[3], thread, attr, arg}, morekeywords={[2], pthread_t, pthread_attr_t}]{snippets/posix_start_thread.c}
    \1 Ein Thread kann mit einer der folgenden drei Arten beendet werden
        \2 Thread ruft Funktion \mylstbox[aboveskip=1mm]{pthread_exit()} auf
        \2 Thread springt aus Thread Routine \mylstbox[aboveskip=1mm]{startRoutine} zurück
        \2 Thread wird mit Funktion \mylstbox[aboveskip=1mm]{pthread_cancel()} abgebrochen
\end{outline}


\subsubsection{Warten, bis ein Thread beendet ist}

\begin{outline}
    \1 Nach dem Starten des Threads bzw. am Ende des main-Programms kann eine Endlos-Schleife eingefügt werden
        \2 \textbf{Dies sollte nie gemacht werden}, da der Prozess so die gesamten CPU-Ressourcen braucht
    \1 Entsprechende Funktion aus pthreads API verwenden
        \lstinputlisting[aboveskip=1mm, linewidth=\linewidth, morekeywords={[3], thread, attr}, morekeywords={[2], pthread_t, pthread_attr_t}]{snippets/posix_wait_for_thread_termination.c}
\end{outline}


\subsection{Beispiel: thread API}

% \begin{center}
%     \includegraphics[width=0.8\columnwidth]{images/posix_thread_fork_join.png}
% \end{center}

\begin{minipage}[t]{0.48\columnwidth}
    \lstinputlisting[aboveskip=1mm, firstnumber=1, firstline=1, lastline=20, morekeywords={[3], arg, ret, dasher, i}, morekeywords={[2], pthread_t}]{snippets/posix_join.c}
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\columnwidth}
    \lstinputlisting[aboveskip=1mm, firstnumber=21, firstline=21, lastline=42, morekeywords={[3], arg, ret, dasher, i}, morekeywords={[2], pthread_t}]{snippets/posix_join.c}
\end{minipage}




\subsection{Thread-safeness}